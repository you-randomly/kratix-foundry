apiVersion: platform.kratix.io/v1alpha1
kind: Promise
metadata:
  name: foundry-instance
  namespace: kratix-platform-system
spec:
  destinationSelectors:
  - matchLabels:
      environment: production
  api:
    apiVersion: apiextensions.k8s.io/v1
    kind: CustomResourceDefinition
    metadata:
      name: foundryinstances.foundry.platform
    spec:
      group: foundry.platform
      names:
        kind: FoundryInstance
        plural: foundryinstances
        singular: foundryinstance
      scope: Namespaced
      versions:
      - name: v1alpha1
        schema:
          openAPIV3Schema:
            type: object
            properties:
              spec:
                type: object
                required:
                - licenseRef
                properties:
                  licenseRef:
                    type: object
                    required: [name]
                    properties:
                      name:
                        type: string
                  foundryVersion:
                    type: string
                    pattern: ^\d+\.\d+(\.\d+)?$
                  resources:
                    type: object
                    properties:
                      cpu: {type: string}
                      memory: {type: string}
                  nfsBasePath:
                    type: string
                  storageBackend:
                    type: string
                    enum: [nfs, pvc]
                    default: nfs
                  proxySSL:
                    type: boolean
                    default: true
                  proxyPort:
                    type: integer
                    default: 443
                  adminPasswordSecretRef:
                    type: object
                    properties:
                      name: {type: string}
                  regeneratePassword:
                    type: boolean

              status:
                type: object
                properties:
                  phase: {type: string}
                  isActive: {type: boolean}
                  connectedPlayers: {type: integer}
                  activeWorld: {type: string}
                  worldActive: {type: boolean}
                  lastSidecarUpdate: {type: string}
                  passwordPendingNotification: {type: boolean}
                  error: {type: string}
                  conditions:
                    type: array
                    items:
                      type: object
                      properties:
                        type: {type: string}
                        status: {type: string}
                        message: {type: string}
        served: true
        storage: true
  dependencies:
    - apiVersion: v1
      kind: ConfigMap
      metadata:
        name: pipeline-scripts
        namespace: foundry-vtt
      data:
        generate_manifests.py: |
          from kubernetes import client, config
          import base64
          import secrets
          import string
          from foundry_lib.manifest_templates import deployment_template, service_template, pvc_template, rbac_templates, credentials_secret_template
          
          def generate_random_password(length=24):
              alphabet = string.ascii_letters + string.digits
              return ''.join(secrets.choice(alphabet) for i in range(length))
          
          def get_existing_password(name, namespace):
              try:
                  # Load config if not already loaded (idempotent)
                  try:
                      config.load_incluster_config()
                  except config.ConfigException:
                      config.load_kube_config()
                      
                  v1 = client.CoreV1Api()
                  secret = v1.read_namespaced_secret(name, namespace)
                  if secret.data and 'adminPassword' in secret.data:
                      return base64.b64decode(secret.data['adminPassword']).decode('utf-8')
              except Exception:
                  pass
              return None
          
          def generate_manifests(pipeline, resource: dict, volume_info: dict, base_domain: str = "k8s.orb.local"):
              """
              Generates Kubernetes manifests for FoundryInstance.
              Returns a dict of status updates (e.g. password notification pending).
              """
              instance_name = resource["metadata"]["name"]
              namespace = resource["metadata"]["namespace"]
              spec = resource.get("spec", {})
              
              # We'll use the pipeline image itself for the monitor as it has all dependencies
              monitor_image = "ghcr.io/you-randomly/kratix-foundry/instance-pipeline:latest"
              
              version = spec.get("foundryVersion", "13.347.0")
              resources = spec.get("resources", {})
              cpu = resources.get("cpu", "100m")
              memory = resources.get("memory", "256Mi")
              proxy_ssl = spec.get("proxySSL", True)
              proxy_port = spec.get("proxyPort", 443)
              
              hostname = f"{instance_name}.{base_domain}"
              
              # Secret Logic
              secret_ref = spec.get("adminPasswordSecretRef", {})
              secret_name = secret_ref.get("name")
              if not secret_name:
                  # Fallback default if not specified (should only happen during migration/dev)
                  secret_name = f"foundry-credentials-{instance_name}"
                  
              regenerate = spec.get("regeneratePassword", False)
              
              admin_password = None
              status_updates = {}
              
              # 1. Check existing
              existing_pw = get_existing_password(secret_name, namespace)
              
              # 2. Decide: Reuse or Generate
              if existing_pw and not regenerate:
                  print(f"Reusing existing password from secret: {secret_name}")
                  admin_password = existing_pw
              else:
                  print(f"Generating new password for secret: {secret_name} (Regenerate={regenerate})")
                  admin_password = generate_random_password()
                  status_updates["passwordPendingNotification"] = True
                  
              # 3. Create Secret via Kubernetes API (not via Kratix output)
              # This avoids Flux conflicts when multiple instances share a secret
              try:
                  config.load_incluster_config()
              except config.ConfigException:
                  config.load_kube_config()
              
              v1 = client.CoreV1Api()
              
              if existing_pw and not regenerate:
                  # Secret exists and not regenerating, skip creation
                  print(f"Secret '{secret_name}' exists, skipping creation")
              elif regenerate:
                  # Regenerating - update existing secret
                  import base64
                  secret_data = {
                      "adminPassword": base64.b64encode(admin_password.encode()).decode()
                  }
                  v1.patch_namespaced_secret(secret_name, namespace, {"data": secret_data})
                  print(f"Regenerated secret via API: {secret_name}")
              else:
                  # Secret doesn't exist - create it
                  import base64
                  secret_data = {
                      "adminPassword": base64.b64encode(admin_password.encode()).decode()
                  }
                  secret_body = client.V1Secret(
                      metadata=client.V1ObjectMeta(name=secret_name, namespace=namespace),
                      data=secret_data,
                      type="Opaque"
                  )
                  try:
                      v1.create_namespaced_secret(namespace, secret_body)
                      print(f"Created secret via API: {secret_name}")
                  except client.exceptions.ApiException as e:
                      if e.status == 409:
                          # Secret was created by another instance (race), just use it
                          print(f"Secret '{secret_name}' already exists (created by another instance)")
                      else:
                          raise
              
              
              storage_backend = volume_info.get("storageBackend", "nfs")
              
              volume_def = {}
              if storage_backend == "pvc":
                  # Generate PVC
                  pvc = pvc_template(instance_name, namespace)
                  pipeline.write_output(f"pvc.yaml", pvc)
                  volume_def = {"persistentVolumeClaim": {"claimName": f"foundry-{instance_name}-data"}}
              else:
                  # NFS Source (Default)
                  volume_def = {
                      "nfs": {
                          "server": volume_info["nfsServer"],
                          "path": volume_info["dataPath"]
                      }
                  }
                  
              # Generate Deployment with Sidecar
              deployment = deployment_template(
                  name=instance_name,
                  namespace=namespace,
                  version=version,
                  cpu=cpu,
                  memory=memory,
                  hostname=hostname,
                  proxy_ssl=proxy_ssl,
                  proxy_port=proxy_port,
                  volume_def=volume_def,
                  admin_secret_name=secret_name,
                  monitor_image=monitor_image,
                  storage_backend=storage_backend
              )
              pipeline.write_output("deployment.yaml", deployment)
              
              # Generate Service
              service = service_template(instance_name, namespace)
              pipeline.write_output("service.yaml", service)
          
              # Generate RBAC for monitor
              rbac = rbac_templates(instance_name, namespace)
              for i, resource in enumerate(rbac):
                  kind = resource["kind"].lower()
                  pipeline.write_output(f"rbac-{kind}.yaml", resource)
              
              print(f"Manifests (including sidecar monitor) generated for instance: {instance_name}")
              return status_updates

        setup_volume.py: |
          def setup_nfs_volume(pipeline, resource: dict) -> dict:
              """
              Creates or references NFS volumes for instance data.
              """
              import os
              
              instance_name = resource["metadata"]["name"]
              spec = resource.get("spec", {})
              
              storage_backend = spec.get("storageBackend", "nfs")
              
              nfs_server = os.environ.get("NFS_SERVER_HOST")
              if storage_backend == "nfs" and not nfs_server:
                  raise ValueError(
                      "NFS storage backend selected but NFS_SERVER_HOST environment variable is not set. "
                      "Either set NFS_SERVER_HOST to your NFS server address, or use storageBackend: pvc"
                  )
              
              nfs_base = os.environ.get("NFS_BASE_PATH", "/exports")
              
              data_path = spec.get("nfsBasePath")
              if not data_path or data_path == "null":
                  data_path = f"{nfs_base}/instances/{instance_name}"
                  
              plugin_path = f"{data_path}/Data/modules"
              world_path = f"{data_path}/Data/worlds"
              
              print("Volume paths resolved:")
              print(f"  Data: {data_path}")
              print(f"  Plugins: {plugin_path}")
              print(f"  Worlds: {world_path}")
          
              # Create directories on NFS if the root is mounted
              nfs_mount_root = os.environ.get("NFS_MOUNT_ROOT", "/mnt/nfs-root")
              if storage_backend == "nfs" and os.path.ismount(nfs_mount_root):
                  print(f"NFS root mounted at {nfs_mount_root}, creating directories...")
                  relative_data_path = data_path.replace(nfs_base, "").lstrip("/")
                  full_modules_path = os.path.join(nfs_mount_root, relative_data_path, "Data", "modules")
                  full_worlds_path = os.path.join(nfs_mount_root, relative_data_path, "Data", "worlds")
                  
                  os.makedirs(full_modules_path, exist_ok=True)
                  os.makedirs(full_worlds_path, exist_ok=True)
                  print(f"  Created: {full_modules_path}")
                  print(f"  Created: {full_worlds_path}")
              else:
                  print(f"NFS root not mounted at {nfs_mount_root}, skipping directory creation.")
          
              volume_info = {
                  "nfsServer": nfs_server,
                  "dataPath": data_path,
                  "pluginPath": plugin_path,
                  "worldPath": world_path,
                  "storageBackend": storage_backend
              }
              
              pipeline.write_metadata("volume-info.yaml", volume_info)
              
              return volume_info

  workflows:
    resource:
      configure:
        - apiVersion: platform.kratix.io/v1alpha1
          kind: Pipeline
          metadata:
            name: instance-configure
          spec:
            rbac:
              permissions:
                - apiGroups: ["foundry.platform"]
                  resources: ["foundrylicenses"]
                  verbs: ["get", "list", "watch", "patch"]
                - apiGroups: [""]
                  resources: ["secrets"]
                  verbs: ["get", "create", "update", "patch"]

            containers:
              - name: configure

                image: ghcr.io/you-randomly/kratix-foundry/instance-pipeline:latest
                imagePullPolicy: Always
                command: ["python3", "/app/scripts/main.py"]
                env:
                  - name: NFS_SERVER_HOST
                    value: "192.168.200.184"
                  - name: NFS_BASE_PATH
                    value: "/volume1/foundry"
                  - name: NFS_MOUNT_ROOT
                    value: "/mnt/nfs-root"
                volumeMounts:
                  - name: license
                    mountPath: /etc/foundry/license
                    readOnly: true
                  - name: pipeline-scripts
                    mountPath: /app/scripts/generate_manifests.py
                    subPath: generate_manifests.py
                  - name: pipeline-scripts
                    mountPath: /app/scripts/setup_volume.py
                    subPath: setup_volume.py
                  - name: nfs-root
                    mountPath: /mnt/nfs-root
            volumes:
              - name: license
                secret:
                  secretName: foundry-license
              - name: pipeline-scripts
                configMap:
                  name: pipeline-scripts
              - name: nfs-root
                nfs:
                  server: 192.168.200.184
                  path: /volume1/foundry
      delete:
        - apiVersion: platform.kratix.io/v1alpha1
          kind: Pipeline
          metadata:
            name: instance-delete
          spec:
            rbac:
              permissions:
                - apiGroups: ["foundry.platform"]
                  resources: ["foundrylicenses"]
                  verbs: ["get", "list", "patch"]
                - apiGroups: [""]
                  resources: ["persistentvolumeclaims"]
                  verbs: ["get", "delete"]
            containers:
              - name: cleanup
                image: ghcr.io/you-randomly/kratix-foundry/instance-pipeline:latest
                imagePullPolicy: Always
                command: ["python3", "/app/scripts/delete.py"]
                volumeMounts:
                  - name: credentials
                    mountPath: /etc/foundry/credentials
                    readOnly: true
            volumes:
              - name: credentials
                secret:
                  secretName: foundry-credentials

    promise:
      configure:
        - apiVersion: platform.kratix.io/v1alpha1
          kind: Pipeline
          metadata:
            name: promise-configure
          spec:
            containers:
              - name: setup-dependencies
                image: ghcr.io/syntasso/kratix-pipeline-utility:v0.0.1
                command:
                  - sh
                  - -c
                  - |
                    set -ex
                    
                    # Create the foundry-vtt namespace
                    cat > /kratix/output/namespace.yaml <<EOF
                    apiVersion: v1
                    kind: Namespace
                    metadata:
                      name: foundry-vtt
                      labels:
                        managed-by: kratix
                        promise: foundry-instance
                    EOF
                    
                    echo "Promise dependencies configured"

