apiVersion: platform.kratix.io/v1alpha1
kind: Promise
metadata:
  name: foundry-instance
  namespace: kratix-platform-system
spec:
  destinationSelectors:
  - matchLabels:
      environment: production
  api:
    apiVersion: apiextensions.k8s.io/v1
    kind: CustomResourceDefinition
    metadata:
      name: foundryinstances.foundry.platform
    spec:
      group: foundry.platform
      names:
        kind: FoundryInstance
        plural: foundryinstances
        singular: foundryinstance
      scope: Namespaced
      versions:
      - name: v1alpha1
        schema:
          openAPIV3Schema:
            type: object
            properties:
              spec:
                type: object
                required:
                - licenseRef
                properties:
                  licenseRef:
                    type: object
                    required: [name]
                    properties:
                      name:
                        type: string
                  foundryVersion:
                    type: string
                    pattern: ^\d+\.\d+(\.\d+)?$
                  resources:
                    type: object
                    properties:
                      cpu: {type: string}
                      memory: {type: string}
                  nfsBasePath:
                    type: string
                  storageBackend:
                    type: string
                    enum: [nfs, pvc]
                    default: nfs
                  proxySSL:
                    type: boolean
                    default: true
                  proxyPort:
                    type: integer
                    default: 443
                  adminPasswordSecretRef:
                    type: object
                    properties:
                      name: {type: string}

              status:
                type: object
                properties:
                  phase: {type: string}
                  isActive: {type: boolean}
                  connectedPlayers: {type: integer}
                  activeWorld: {type: string}
                  worldActive: {type: boolean}
                  lastSidecarUpdate: {type: string}
                  error: {type: string}
                  conditions:
                    type: array
                    items:
                      type: object
                      properties:
                        type: {type: string}
                        status: {type: string}
                        message: {type: string}
        served: true
        storage: true
  dependencies:
    - apiVersion: v1
      kind: ConfigMap
      metadata:
        name: pipeline-scripts
        namespace: foundry-vtt
      data:
        generate_manifests.py: |
          from foundry_lib.manifest_templates import deployment_template, service_template, pvc_template, rbac_templates
          
          
          def external_secret_template(instance_name: str, namespace: str, secret_name: str) -> dict:
              """
              Generates an ExternalSecret resource that uses the ClusterGenerator to create passwords.
              The secret won't auto-refresh (refreshInterval: 0).
              Manual refresh is triggered by annotating with force-sync.
              """
              return {
                  "apiVersion": "external-secrets.io/v1",
                  "kind": "ExternalSecret",
                  "metadata": {
                      "name": secret_name,
                      "namespace": namespace,
                      "labels": {
                          "foundry.platform/instance": instance_name,
                          "managed-by": "kratix"
                      }
                  },
                  "spec": {
                      "refreshInterval": "0",
                      "target": {
                          "name": secret_name,
                          "template": {
                              "data": {
                                  "adminPassword": "{{ .password }}"
                              }
                          }
                      },
                      "dataFrom": [
                          {
                              "sourceRef": {
                                  "generatorRef": {
                                      "apiVersion": "generators.external-secrets.io/v1alpha1",
                                      "kind": "ClusterGenerator",
                                      "name": "foundry-password"
                                  }
                              }
                          }
                      ]
                  }
              }
          
          
          def generate_manifests(pipeline, resource: dict, volume_info: dict, base_domain: str = "k8s.orb.local"):
              """
              Generates Kubernetes manifests for FoundryInstance.
              Password management is delegated to External Secrets Operator.
              """
              instance_name = resource["metadata"]["name"]
              namespace = resource["metadata"]["namespace"]
              spec = resource.get("spec", {})
              
              monitor_image = "ghcr.io/you-randomly/kratix-foundry/instance-pipeline:latest"
              
              version = spec.get("foundryVersion", "13.347.0")
              resources = spec.get("resources", {})
              cpu = resources.get("cpu", "100m")
              memory = resources.get("memory", "256Mi")
              proxy_ssl = spec.get("proxySSL", True)
              proxy_port = spec.get("proxyPort", 443)
              
              hostname = f"{instance_name}.{base_domain}"
              
              # Secret name - use ref if provided, otherwise generate from instance name
              secret_ref = spec.get("adminPasswordSecretRef", {})
              secret_name = secret_ref.get("name")
              if not secret_name:
                  secret_name = f"foundry-credentials-{instance_name}"
              
              # Generate ExternalSecret only if it's instance-specific
              # Shared secrets (ending with -default) should only be created once, not by every instance
              is_instance_specific = instance_name in secret_name and not secret_name.endswith("-default")
              
              if is_instance_specific:
                  external_secret = external_secret_template(instance_name, namespace, secret_name)
                  pipeline.write_output("external-secret.yaml", external_secret)
                  print(f"Generated ExternalSecret: {secret_name} (password managed by ESO)")
              else:
                  print(f"Using shared secret: {secret_name} (ExternalSecret not generated to avoid duplicates)")
              
              storage_backend = volume_info.get("storageBackend", "nfs")
              
              volume_def = {}
              if storage_backend == "pvc":
                  pvc = pvc_template(instance_name, namespace)
                  pipeline.write_output(f"pvc.yaml", pvc)
                  volume_def = {"persistentVolumeClaim": {"claimName": f"foundry-{instance_name}-data"}}
              else:
                  volume_def = {
                      "nfs": {
                          "server": volume_info["nfsServer"],
                          "path": volume_info["dataPath"]
                      }
                  }
                  
              deployment = deployment_template(
                  name=instance_name,
                  namespace=namespace,
                  version=version,
                  cpu=cpu,
                  memory=memory,
                  hostname=hostname,
                  proxy_ssl=proxy_ssl,
                  proxy_port=proxy_port,
                  volume_def=volume_def,
                  admin_secret_name=secret_name,
                  monitor_image=monitor_image,
                  storage_backend=storage_backend
              )
              pipeline.write_output("deployment.yaml", deployment)
              
              service = service_template(instance_name, namespace)
              pipeline.write_output("service.yaml", service)
          
              rbac = rbac_templates(instance_name, namespace)
              for i, resource in enumerate(rbac):
                  kind = resource["kind"].lower()
                  pipeline.write_output(f"rbac-{kind}.yaml", resource)
              
              print(f"Manifests (including sidecar monitor) generated for instance: {instance_name}")

        setup_volume.py: |
          def setup_nfs_volume(pipeline, resource: dict) -> dict:
              """
              Creates or references NFS volumes for instance data.
              """
              import os
              
              instance_name = resource["metadata"]["name"]
              spec = resource.get("spec", {})
              
              storage_backend = spec.get("storageBackend", "nfs")
              
              nfs_server = os.environ.get("NFS_SERVER_HOST")
              if storage_backend == "nfs" and not nfs_server:
                  raise ValueError(
                      "NFS storage backend selected but NFS_SERVER_HOST environment variable is not set. "
                      "Either set NFS_SERVER_HOST to your NFS server address, or use storageBackend: pvc"
                  )
              
              nfs_base = os.environ.get("NFS_BASE_PATH", "/exports")
              
              data_path = spec.get("nfsBasePath")
              if not data_path or data_path == "null":
                  data_path = f"{nfs_base}/instances/{instance_name}"
                  
              plugin_path = f"{data_path}/Data/modules"
              world_path = f"{data_path}/Data/worlds"
              
              print("Volume paths resolved:")
              print(f"  Data: {data_path}")
              print(f"  Plugins: {plugin_path}")
              print(f"  Worlds: {world_path}")
          
              # Create directories on NFS if the root is mounted
              nfs_mount_root = os.environ.get("NFS_MOUNT_ROOT", "/mnt/nfs-root")
              if storage_backend == "nfs" and os.path.ismount(nfs_mount_root):
                  print(f"NFS root mounted at {nfs_mount_root}, creating directories...")
                  relative_data_path = data_path.replace(nfs_base, "").lstrip("/")
                  full_modules_path = os.path.join(nfs_mount_root, relative_data_path, "Data", "modules")
                  full_worlds_path = os.path.join(nfs_mount_root, relative_data_path, "Data", "worlds")
                  
                  os.makedirs(full_modules_path, exist_ok=True)
                  os.makedirs(full_worlds_path, exist_ok=True)
                  print(f"  Created: {full_modules_path}")
                  print(f"  Created: {full_worlds_path}")
              else:
                  print(f"NFS root not mounted at {nfs_mount_root}, skipping directory creation.")
          
              volume_info = {
                  "nfsServer": nfs_server,
                  "dataPath": data_path,
                  "pluginPath": plugin_path,
                  "worldPath": world_path,
                  "storageBackend": storage_backend
              }
              
              pipeline.write_metadata("volume-info.yaml", volume_info)
              
              return volume_info

  workflows:
    resource:
      configure:
        - apiVersion: platform.kratix.io/v1alpha1
          kind: Pipeline
          metadata:
            name: instance-configure
          spec:
            rbac:
              permissions:
                - apiGroups: ["foundry.platform"]
                  resources: ["foundrylicenses"]
                  verbs: ["get", "list", "watch", "patch"]
                - apiGroups: ["external-secrets.io"]
                  resources: ["externalsecrets"]
                  verbs: ["get", "create", "update", "patch", "delete"]

            containers:
              - name: configure

                image: ghcr.io/you-randomly/kratix-foundry/instance-pipeline:latest
                imagePullPolicy: Always
                command: ["python3", "/app/scripts/main.py"]
                env:
                  - name: NFS_SERVER_HOST
                    value: "192.168.200.184"
                  - name: NFS_BASE_PATH
                    value: "/volume1/foundry"
                  - name: NFS_MOUNT_ROOT
                    value: "/mnt/nfs-root"
                volumeMounts:
                  - name: license
                    mountPath: /etc/foundry/license
                    readOnly: true
                  - name: pipeline-scripts
                    mountPath: /app/scripts/generate_manifests.py
                    subPath: generate_manifests.py
                  - name: pipeline-scripts
                    mountPath: /app/scripts/setup_volume.py
                    subPath: setup_volume.py
                  - name: nfs-root
                    mountPath: /mnt/nfs-root
            volumes:
              - name: license
                secret:
                  secretName: foundry-license
              - name: pipeline-scripts
                configMap:
                  name: pipeline-scripts
              - name: nfs-root
                nfs:
                  server: 192.168.200.184
                  path: /volume1/foundry
      delete:
        - apiVersion: platform.kratix.io/v1alpha1
          kind: Pipeline
          metadata:
            name: instance-delete
          spec:
            rbac:
              permissions:
                - apiGroups: ["foundry.platform"]
                  resources: ["foundrylicenses"]
                  verbs: ["get", "list", "patch"]
                - apiGroups: [""]
                  resources: ["persistentvolumeclaims"]
                  verbs: ["get", "delete"]
            containers:
              - name: cleanup
                image: ghcr.io/you-randomly/kratix-foundry/instance-pipeline:latest
                imagePullPolicy: Always
                command: ["python3", "/app/scripts/delete.py"]
                volumeMounts:
                  - name: credentials
                    mountPath: /etc/foundry/credentials
                    readOnly: true
            volumes:
              - name: credentials
                secret:
                  secretName: foundry-credentials

    promise:
      configure:
        - apiVersion: platform.kratix.io/v1alpha1
          kind: Pipeline
          metadata:
            name: promise-configure
          spec:
            containers:
              - name: setup-dependencies
                image: ghcr.io/syntasso/kratix-pipeline-utility:v0.0.1
                command:
                  - sh
                  - -c
                  - |
                    set -ex
                    
                    # Create the foundry-vtt namespace
                    cat > /kratix/output/namespace.yaml <<EOF
                    apiVersion: v1
                    kind: Namespace
                    metadata:
                      name: foundry-vtt
                      labels:
                        managed-by: kratix
                        promise: foundry-instance
                    EOF
                    
                    # Create ClusterGenerator for password generation (ESO)
                    cat > /kratix/output/cluster-generator.yaml <<EOF
                    apiVersion: generators.external-secrets.io/v1alpha1
                    kind: ClusterGenerator
                    metadata:
                      name: foundry-password
                      labels:
                        managed-by: kratix
                        promise: foundry-instance
                    spec:
                      kind: Password
                      generator:
                        passwordSpec:
                          length: 24
                          digits: 4
                          symbols: 0
                          noUpper: false
                          allowRepeat: true
                    EOF
                    
                    echo "Promise dependencies configured"
