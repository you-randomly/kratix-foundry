apiVersion: platform.kratix.io/v1alpha1
kind: Promise
metadata:
  name: foundry-instance
  namespace: kratix-platform-system
spec:
  destinationSelectors:
  - matchLabels:
      environment: production
  api:
    apiVersion: apiextensions.k8s.io/v1
    kind: CustomResourceDefinition
    metadata:
      name: foundryinstances.foundry.platform
    spec:
      group: foundry.platform
      names:
        kind: FoundryInstance
        plural: foundryinstances
        singular: foundryinstance
      scope: Namespaced
      versions:
      - name: v1alpha1
        schema:
          openAPIV3Schema:
            type: object
            properties:
              spec:
                type: object
                required:
                - licenseRef
                properties:
                  licenseRef:
                    type: object
                    required: [name]
                    properties:
                      name:
                        type: string
                  foundryVersion:
                    type: string
                    pattern: ^\d+\.\d+(\.\d+)?$
                  resources:
                    type: object
                    properties:
                      cpu: {type: string}
                      memory: {type: string}
                  nfsBasePath:
                    type: string
                  storageBackend:
                    type: string
                    enum: [nfs, pvc]
                    default: nfs
                  proxySSL:
                    type: boolean
                    default: true
                  proxyPort:
                    type: integer
                    default: 443
                  adminPasswordSecretRef:
                    type: object
                    properties:
                      name: {type: string}
                  regeneratePassword:
                    type: boolean

              status:
                type: object
                properties:
                  phase: {type: string}
                  isActive: {type: boolean}
                  connectedPlayers: {type: integer}
                  activeWorld: {type: string}
                  worldActive: {type: boolean}
                  lastSidecarUpdate: {type: string}
                  passwordPendingNotification: {type: boolean}
                  error: {type: string}
                  conditions:
                    type: array
                    items:
                      type: object
                      properties:
                        type: {type: string}
                        status: {type: string}
                        message: {type: string}
        served: true
        storage: true
  dependencies:
    - apiVersion: v1
      kind: ConfigMap
      metadata:
        name: pipeline-scripts
        namespace: foundry-vtt
      data:
        generate_manifests.py: |
          from kubernetes import client, config
          import base64
          import secrets
          import string
          from foundry_lib.manifest_templates import deployment_template, service_template, pvc_template, rbac_templates, credentials_secret_template
          
          def generate_random_password(length=24):
              alphabet = string.ascii_letters + string.digits
              return ''.join(secrets.choice(alphabet) for i in range(length))
          
          def get_existing_password(name, namespace):
              try:
                  # Load config if not already loaded (idempotent)
                  try:
                      config.load_incluster_config()
                  except config.ConfigException:
                      config.load_kube_config()
                      
                  v1 = client.CoreV1Api()
                  secret = v1.read_namespaced_secret(name, namespace)
                  if secret.data and 'adminPassword' in secret.data:
                      return base64.b64decode(secret.data['adminPassword']).decode('utf-8')
              except Exception:
                  pass
              return None
          
          def generate_manifests(pipeline, resource: dict, volume_info: dict, base_domain: str = "k8s.orb.local"):
              """
              Generates Kubernetes manifests for FoundryInstance.
              Returns a dict of status updates (e.g. password notification pending).
              """
              instance_name = resource["metadata"]["name"]
              namespace = resource["metadata"]["namespace"]
              spec = resource.get("spec", {})
              
              # We'll use the pipeline image itself for the monitor as it has all dependencies
              monitor_image = "ghcr.io/you-randomly/kratix-foundry/instance-pipeline:latest"
              
              version = spec.get("foundryVersion", "13.347.0")
              resources = spec.get("resources", {})
              cpu = resources.get("cpu", "100m")
              memory = resources.get("memory", "256Mi")
              proxy_ssl = spec.get("proxySSL", True)
              proxy_port = spec.get("proxyPort", 443)
              
              hostname = f"{instance_name}.{base_domain}"
              
              # Secret Logic
              secret_ref = spec.get("adminPasswordSecretRef", {})
              secret_name = secret_ref.get("name")
              if not secret_name:
                  # Fallback default if not specified (should only happen during migration/dev)
                  secret_name = f"foundry-credentials-{instance_name}"
                  
              regenerate = spec.get("regeneratePassword", False)
              
              admin_password = None
              status_updates = {}
              
              # 1. Check existing
              existing_pw = get_existing_password(secret_name, namespace)
              
              # 2. Decide: Reuse or Generate
              if existing_pw and not regenerate:
                  print(f"Reusing existing password from secret: {secret_name}")
                  admin_password = existing_pw
              else:
                  print(f"Generating new password for secret: {secret_name} (Regenerate={regenerate})")
                  admin_password = generate_random_password()
                  status_updates["passwordPendingNotification"] = True
                  
              # 3. Generate Secret Manifest
              # Only generate if it's the default (dedicated) secret. Shared secrets should be managed externally or by the first instance.
              default_secret_name = f"foundry-credentials-{instance_name}"
              if secret_name == default_secret_name:
                  secret_manifest = credentials_secret_template(secret_name, namespace, admin_password)
                  pipeline.write_output("secret.yaml", secret_manifest)
              else:
                  print(f"Skipping generation of shared/external secret: {secret_name}")
              
              
              storage_backend = volume_info.get("storageBackend", "nfs")
              
              volume_def = {}
              if storage_backend == "pvc":
                  # Generate PVC
                  pvc = pvc_template(instance_name, namespace)
                  pipeline.write_output(f"pvc.yaml", pvc)
                  volume_def = {"persistentVolumeClaim": {"claimName": f"foundry-{instance_name}-data"}}
              else:
                  # NFS Source (Default)
                  volume_def = {
                      "nfs": {
                          "server": volume_info["nfsServer"],
                          "path": volume_info["dataPath"]
                      }
                  }
                  
              # Generate Deployment with Sidecar
              deployment = deployment_template(
                  name=instance_name,
                  namespace=namespace,
                  version=version,
                  cpu=cpu,
                  memory=memory,
                  hostname=hostname,
                  proxy_ssl=proxy_ssl,
                  proxy_port=proxy_port,
                  volume_def=volume_def,
                  admin_secret_name=secret_name,
                  monitor_image=monitor_image
              )
              pipeline.write_output("deployment.yaml", deployment)
              
              # Generate Service
              service = service_template(instance_name, namespace)
              pipeline.write_output("service.yaml", service)
          
              # Generate RBAC for monitor
              rbac = rbac_templates(instance_name, namespace)
              for i, resource in enumerate(rbac):
                  kind = resource["kind"].lower()
                  pipeline.write_output(f"rbac-{kind}.yaml", resource)
              
              print(f"Manifests (including sidecar monitor) generated for instance: {instance_name}")
              return status_updates

  workflows:
    resource:
      configure:
        - apiVersion: platform.kratix.io/v1alpha1
          kind: Pipeline
          metadata:
            name: instance-configure
          spec:
            rbac:
              permissions:
                - apiGroups: ["foundry.platform"]
                  resources: ["foundrylicenses"]
                - apiGroups: ["foundry.platform"]
                  resources: ["foundrylicenses"]
                  verbs: ["get", "list", "watch", "patch"]
                - apiGroups: [""]
                  resources: ["secrets"]
                  verbs: ["get", "create", "update", "patch"]

            containers:
              - name: configure

                image: ghcr.io/you-randomly/kratix-foundry/instance-pipeline:latest
                imagePullPolicy: Always
                command: ["python3", "/app/scripts/main.py"]
                env:
                  - name: NFS_SERVER_HOST
                    value: "192.168.200.184"
                  - name: NFS_BASE_PATH
                    value: "/volume1/foundry"
                volumeMounts:
                  - name: license
                    mountPath: /etc/foundry/license
                    readOnly: true
                  - name: pipeline-scripts
                    mountPath: /app/scripts/generate_manifests.py
                    subPath: generate_manifests.py
            volumes:
              - name: license
                secret:
                  secretName: foundry-license
              - name: pipeline-scripts
                configMap:
                  name: pipeline-scripts
      delete:
        - apiVersion: platform.kratix.io/v1alpha1
          kind: Pipeline
          metadata:
            name: instance-delete
          spec:
            rbac:
              permissions:
                - apiGroups: ["foundry.platform"]
                  resources: ["foundrylicenses"]
                  verbs: ["get", "list", "patch"]
                - apiGroups: [""]
                  resources: ["persistentvolumeclaims"]
                  verbs: ["get", "delete"]
            containers:
              - name: cleanup
                image: ghcr.io/you-randomly/kratix-foundry/instance-pipeline:latest
                imagePullPolicy: Always
                command: ["python3", "/app/scripts/delete.py"]
                volumeMounts:
                  - name: credentials
                    mountPath: /etc/foundry/credentials
                    readOnly: true
            volumes:
              - name: credentials
                secret:
                  secretName: foundry-credentials

    promise:
      configure:
        - apiVersion: platform.kratix.io/v1alpha1
          kind: Pipeline
          metadata:
            name: promise-configure
          spec:
            containers:
              - name: setup-dependencies
                image: ghcr.io/syntasso/kratix-pipeline-utility:v0.0.1
                command:
                  - sh
                  - -c
                  - |
                    set -ex
                    
                    # Create the foundry-vtt namespace
                    cat > /kratix/output/namespace.yaml <<EOF
                    apiVersion: v1
                    kind: Namespace
                    metadata:
                      name: foundry-vtt
                      labels:
                        managed-by: kratix
                        promise: foundry-instance
                    EOF
                    
                    echo "Promise dependencies configured"

